---
title: "컴퓨터 네트워크 스터디 3주차"
excerpt: "Cookie, Session, JWT"
categories:
  - computerNetwork
---

> 컴퓨터 내트워크 스터디 3주차

# Statefull : Cookie , Session, JWT

## HTTP

HTTP는 **Connectionless, Stateless** 특성을 지닌다.
~less는 ~하지 않는 것이라는 뜻.
즉 **HTTP는 연결과 상태를 유지하지 않는다**

> ### Conncectionless
>
> HTTP는 TCP connection을 유지시키지 않는다.
> 즉, Request를 받고 Response를 보내면 둘은 연결이 끊어진다.
> (TCP connection을 유지하는 Keep-alive는 고려하지 않음)

> ### Stateless
>
> HTTP는 상태정보를 저장하지 않는다.
> 따라서 연결이 끊어지는 순간 모든 상태 정보가 사라진다.

이러한 HTTP의 본질적인 특징 때문에 Cookie와 Session이 필요하다.
만일 Cookie와 Session이 없다면 아래와 같이 통신은 치매 걸린 단말들의 대화가 될 것이다.

A : 안녕! 내 이름은 A야. 사탕 먹을래?
B : 안녕! A야. 고마워~~ 잘먹을께
A : 너는 이름이 뭐야?
B : 누구세요? (정말 모름)

## Cookie

쿠키는 클라이언트에 저장되는 키와 값이 포함된 작은 데이터 파일이다.
이러한 쿠키는 다음과 같이 구성된다.

- 이름 : 쿠키의 이름
- 값 : 쿠키의 값
- 파기시점 : 쿠키의 명줄
- 도메인 : 쿠키가 적용되는 도메인
- 경로 : 쿠키의 도메인에 있는 경로

쿠키의 작동 방식은 아래와 같다.

1. 클라이언트가 서버에 정보를 요청한다.
2. 서버는 쿠키를 포함한 응답을 보낸다.
3. 클라이언트는 쿠키를 로컬 저장소인 쿠키 저장소에 저장한다.
4. 클라이언트는 서버에 재접속을 한다. 이때 쿠키 저장소에 있는 쿠키를 꺼내서 요청을 한다.
5. 서버는 쿠키를 읽어 클라이언트를 식별한다.

## Session

클라이언트에 로컬 저장소를 이용하여 쿠키를 관리하고, 서버에 요청 시 이 쿠키를 포함하여 HTTP request를 한다.
그러나, 민감한 정보가 이에 포함되고 누군가 이를 갈취해간다면 우리의 개인정보는 그대로 털릴 것이다.
이를 위해 세션이라는 개념이 도입되었다.
세션 또한 쿠키의 일종이라 볼 수 있는데, 다만 핵심 정보를 클라이언트 측이 아닌 서버 측이 가지고 있는 것이다.

세션의 작동 방식은 아래와 같다.

1. 클라이언트가 서버에 정보를 요청한다.
2. 서버는 클라이언트의 정보를 서버 측 저장소인 세션 저장소에 기록, 그리고 이 기록의 인덱스(sessionID)를 담은 쿠키를 생성하여 이를 포함해 응답을 보낸다.
3. 클라이언트는 인덱스(sessionID)가 담긴 쿠키를 로컬 저장소인 쿠키 저장소에 저장한다.
4. 클라이언트는 서버에 재접속을 한다. 이때 쿠키 저장소에 있는 쿠키를 꺼내서 요청을 한다.
5. 서버는 쿠키를 읽어 인덱스(sessionID)를 파악하고 세션 저장소를 확인해 클라이언트를 식별한다.

## cookie vs session

쿠키는 중요 정보를 클라이언트에 저장하여 빠르고, 브라우저를 종료해도 정보가 그대로 남아 있다.
그러나 요청을 보낼 때 스니핑 당한다면 개인정보를 털릴 수 있다.
세션은 중요 정보를 서버가 가지고 있으므로 스니핑 당해도 아무런 걱정이 없다.
그러나 서버의 자원을 사용하기 때문에 서버에 요청자가 많을 경우 서버가 부하가 걸린다.
즉, **신속/편의성을 지닌 쿠키 vs 보안성을 지닌 세션**을 알맞게 적용해야 한다.

그렇다면, 쿠키처럼 서버에 부담도 가지 않으면서 세션처럼 보안성도 갖춘 존나 섹시한 개념은 존재하지 않는 것일까?
존재한다. 그게 바로 JWT이다.

## JWT

JWT는 Json Web Token의 약어이다.
Json 객체에 인증에 필요한 정보를 담은 뒤, 서버가 가진 비밀키로 서명한 토큰이다.
즉, JWT는 **암호화한 쿠키**라고 생각하면 된다.
JWT는 Header, Payload, Signature로 구성되어 있다.

- Header
  - 암호화 알고리즘, 토큰 타입
- Payload
  - 토큰의 내용
- Signature
  - Header, Payload를 헤더에서 선언한 암호화 방식으로 암호화 된 것

따라서 JWT는 토큰을 사용해 사용자 상태를 서버가 저장하지 않아도 되며, 서버만이 복호화 할 수 있는 비밀키를 가지고 있기에 보안성에도 문제가 없는 방식이다.
그러나, 한번 발급해 서버의 손을 떠난 토큰은 변경할 수 없다는 것과 토큰의 크기가 커지면 트래픽에 영향이 미칠 수 있다는 단점을 지니고 있다.

---

# SOP, CORS

## Same-Origin Policy

SOP란 Same-Origin Policy의 약어다.
이는 같은 출처에 대해서만 접근을 허용하는 정책이다.
브라우저가 사용자를 악의적인 코드로부터 보호하기 위해서 만들어졌다.
이떄 출처란 protocol, host, port를 의미한다.

> 즉, SOP 란 동일 protocol, host, port를 가진 사이트에서만 리소스를 공유할 수 있다는 정책

그러나 현재의 웹 사이트는 여러 API들이 각각 다른 출처로 리소스를 요청해야 한다.
따라서 API를 실행하려하면 에러가 발생하는데, 이는 SOP가 오히려 방해되는 정책이 된다.

그러기에 CORS, Cross-Origin Resource Sharing이란 개념이 필요하게 되었다.

## Cross-Origin Resource Sharing

API들이 제3자인 다른 출처로부터 리소스를 받는 것을 허용하는 정책이다.
SOP가 기본값, 그리고 백엔드에서 각 API에 필요로 하는 출처에 CORS 정보를 기입하면 된다.
[MDN Document : CORS](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)

---

> 참고 자료
> [얄팍한 코딩사전 : Session, JW](https://youtu.be/1QiOXWEbqYQ?si=2D8rRxqhDZcNtrrf) >[얄팍한 코딩사전 : CORS](https://youtu.be/bW31xiNB8Nc?si=xFNm0HuYxQjlBcU6) >[Vellog : CORS](https://hudi.blog/sop-and-cors/)
