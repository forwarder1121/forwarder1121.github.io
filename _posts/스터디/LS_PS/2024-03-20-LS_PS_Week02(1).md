---
title: "C++ 코딩테스트 Week 01 추천문제"
excerpt: "시간복잡도, 공간복잡도, 누적합"
categories:
    - 백준
---

# [2309] 일곱 난쟁이

> # 일곱 난쟁이
>
> | 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
> | :-------- | :---------- | :----- | :---- | :-------- | :-------- |
> | 2 초      | 128 MB      | 142307 | 59233 | 41529     | 41.757%   |
>
> ## 문제
>
> 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
>
> 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
>
> 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.
>
> ## 입력
>
> 아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.
>
> ## 출력
>
> 일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.
>
> ## 예제 입력 1 복사
>
> ```
> 20
> 7
> 23
> 19
> 10
> 15
> 25
> 8
> 13
> ```
>
> ## 예제 출력 1 복사
>
> ```
> 7
> 8
> 10
> 13
> 19
> 20
> 23
> ```

강의에서 누적합을 배운 잔상이 남아서 누적합으로 구현하는 건가 한참 고민했는데, 그러면 순서가 정해지게 되어 문제에 적합한 알고리즘이 아닌 것을 깨달았다.

서핑좀 하다 찾은게 바로 **역발상**이다

9C7=9C2 임을 상기할것

7명의 합을 구하는게 아니라 2명을 뺀 값이 100이 되면 된다.

만일 N명이 있다 할때, 뺄 사람 두명 선택하는 경우에 대한 시간복잡도는 O(N^2)

그리고 애초에 N=7명이라 시간복잡도를 생각하지 않아도 된다

역발상/2명 빼기

```cpp
#include <stdio.h>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    //input
    vector<int> v(9);
    pair<int, int> ret;
    for(int i=0;i<9;i++) {
       cin>>v[i];
    }
    sort(v.begin(),v.end());

    int total = 0;
    int fake[2];
    for(int i:v) total+=i;
    //select two elements be subtracted
    for(int i=0;i<9;i++) {
        for(int j=i+1;j<9;j++) {
            if(total-v[i]-v[j]==100) {
                ret={i,j};
                goto end;
            }
        }
    }
end:
    for(int i=0;i<9;i++) {
        if(i==ret.first||i==ret.second) continue;
       cout<<v[i]<<" ";
    }
    return 0;

}
```

재귀 : next_permutation

do {}while(next_permutation) 이용

```cpp
#include <stdio.h>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    //input
    vector<int> v(9);
    for(int i=0;i<9;i++) {
       cin>>v[i];
    }
    sort(v.begin(),v.end());

    do{
        int sum=0;
        for(int i=0;i<7;i++) sum+=v[i];
        if(sum==100) break;
    }while(next_permutation(v.begin(),v.end()));
    for(int i=0;i<7;i++) cout<<v[i]<<" ";
}
```

재귀 : 직접 구현(makePermutation)

메인 로직을 따로 함수로 만들어서 구현

```cpp
#include <stdio.h>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int a[9];
int n=9,r=7;

void solve(){
    int sum=0;
    for(int i=0;i<r;i++){
        sum+=a[i];
    }
    if(sum==100){
        sort(a,a+7);
        for(int i=0;i<r;i++) cout<<a[i]<<"\n";
        exit(0);
    }
}

void print(){
    for(int i=0;i<r;i++) cout<<a[i]<<" ";
    cout<<"\n";
}

void makePermutation(int n,int r,int depth){
    if(r==depth){
        solve();
        return;
    }
    for(int i=depth;i<n;i++){
        swap(a[depth],a[i]);
        makePermutation(n,r,depth+1);
        swap(a[depth],a[i]);
    }
    return;
}

int main(){
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    makePermutation(n,r,0);
    return 0;
}
```

---

# [10808] 알파벳 개수

> # 알파벳 개수
>
> | 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 1 초      | 256 MB      | 50684 | 34468 | 27694     | 68.544%   |
>
> ## 문제
>
> 알파벳 소문자로만 이루어진 단어 S가 주어진다. 각 알파벳이 단어에 몇 개가 포함되어 있는지 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.
>
> ## 출력
>
> 단어에 포함되어 있는 a의 개수, b의 개수, …, z의 개수를 공백으로 구분해서 출력한다.
>
> ## 예제 입력 1 복사
>
> ```
> baekjoon
> ```
>
> ## 예제 출력 1 복사
>
> ```
> 1 1 0 0 1 0 0 0 0 1 1 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0
> ```

단순하게 구현

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <vector>
using namespace std;
int main(){

    //input
    string str;
    cin>>str;
    vector<int> v(26);
    for(int i=0;i<26;i++){
        char check='a'+i;
        for(int j=0;j<str.length();j++){
            if(str[j]==check) v[i]++;
        }
    }

    for(int i:v){
        cout<<i<<" ";
    }


    return 0;
}
```

시간 복잡도 : 26N (N은 문자열의 길이)

**CountingStar는 Map 또는 배열**!!

Map : String 기반

Array : Int 기반

나는 i번째 문자가 무엇인지 확인하는 과정을 거쳤는데, 강의를 들으니까 사실 이 과정이 필요 없다는 것을 깨달았다

그냥 모든 문자에 대해 배열 값을 증가시키면 되기 때문

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <vector>
using namespace std;
string str;
int cnt[26];
int main(){
    cin>>str;
    for(char a:str){
        cnt[a-'a']++;
    }
    for(int i:cnt) cout<<i<<" ";
    return 0;
}
```

시간 복잡도 : N

전역변수로 만들면 알아서 0으로 초기화가 되어 편하다

---

# [2979] 트럭주차

> # 트럭 주차
>
> | 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :--- | :-------- | :-------- |
> | 1 초      | 128 MB      | 10526 | 7165 | 5687      | 67.880%   |
>
> ## 문제
>
> 상근이는 트럭을 총 세 대 가지고 있다. 오늘은 트럭을 주차하는데 비용이 얼마나 필요한지 알아보려고 한다.
>
> 상근이가 이용하는 주차장은 주차하는 트럭의 수에 따라서 주차 요금을 할인해 준다.
>
> 트럭을 한 대 주차할 때는 1분에 한 대당 A원을 내야 한다. 두 대를 주차할 때는 1분에 한 대당 B원, 세 대를 주차할 때는 1분에 한 대당 C원을 내야 한다.
>
> A, B, C가 주어지고, 상근이의 트럭이 주차장에 주차된 시간이 주어졌을 때, 주차 요금으로 얼마를 내야 하는지 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 문제에서 설명한 주차 요금 A, B, C가 주어진다. (1 ≤ C ≤ B ≤ A ≤ 100)
>
> 다음 세 개 줄에는 두 정수가 주어진다. 이 정수는 상근이가 가지고 있는 트럭이 주차장에 도착한 시간과 주차장에서 떠난 시간이다. 도착한 시간은 항상 떠난 시간보다 앞선다. 입력으로 주어지는 시간은 1과 100사이 이다.
>
> ## 출력
>
> 첫째 줄에 상근이가 내야하는 주차 요금을 출력한다.
>
> ## 예제 입력 1 복사
>
> ```
> 5 3 1
> 1 6
> 3 5
> 2 8
> ```
>
> ## 예제 출력 1 복사
>
> ```
> 33
> ```
>
> ## 예제 입력 2 복사
>
> ```
> 10 8 6
> 15 30
> 25 50
> 70 80
> ```
>
> ## 예제 출력 2 복사
>
> ```
> 480
> ```

단순하게 구현 (시각을 i 반복변수로 설정하여)

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <vector>
using namespace std;

int main(){
    //input
    int taxes[3];
    int total = 0;
    for(int i=0; i<3; i++) cin>>taxes[i];
    int arriveTimes[3];
    int departureTimes[3];
    for(int i=0;i<3;i++) {
        cin>>arriveTimes[i];
        cin>>departureTimes[i];
    }

    //get min,max time
    int minTime=arriveTimes[0],maxTime=departureTimes[0];
    for(int i=1; i<3; i++){
        if(minTime>arriveTimes[i]) minTime=arriveTimes[i];
        if(maxTime<departureTimes[i]) maxTime=departureTimes[i];
    }

    //check time i
    for(int i=minTime;i<=maxTime;i++){
        int numOfCars=0;
        for(int car=0;car<3;car++) {
            if(i>=arriveTimes[car]&&i<departureTimes[car]){
                numOfCars++;
            }
        }
        total+=taxes[numOfCars-1]*numOfCars;
    }
    cout<<total;
}
```

이때, **시각을 이상 - 미만** 인것을 인지

모범 답안 -> 아예 시간을 배열로 만들고, 시간을 이상 - 미만 로직에 맞게 구현

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <vector>
using namespace std;
int A,B,C,a,b,cnt[104],ret;
int main(){
    cin>>A>>B>>C;
    for(int i=0;i<3;i++){
        cin>>a>>b;
        for(int j=a;j<b;j++) cnt[j]++;
    }
    for(int j=1;j<100;j++){
        if(cnt[j]){
            if(cnt[j]==1) ret+=A;
            else if(cnt[j]==2) ret+=B*2;
            else if(cnt[j]==3) ret+=C*3;
        }
    }
    cout<<ret<<"\n";
    return 0;
}
```

---

# [10988] 팰린드롬인지 확인하기

> | 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 1 초      | 256 MB      | 70832 | 43313 | 37136     | 61.531%   |
>
> ## 문제
>
> 알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.
>
> 팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.
>
> level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.
>
> ## 입력
>
> 첫째 줄에 단어가 주어진다. 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.
>
> ## 출력
>
> 첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다.
>
> ## 예제 입력 1 복사
>
> ```
> level
> ```
>
> ## 예제 출력 1 복사
>
> ```
> 1
> ```
>
> ## 예제 입력 2 복사
>
> ```
> baekjoon
> ```
>
> ## 예제 출력 2 복사
>
> ```
> 0
> ```

너무 쉽다

cpp의 reverse() 사용법 숙지하는 문제

모범답안보다 내 코드가 더 깔끔함

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
string str1, str2;

int main(){

    cin>>str1;
    str2=str1;
    reverse(str1.begin(), str1.end());

    cout<<(str1==str2)<<endl;
    return 0;
}

```

---

# [1159] 농구 경기

> # 농구 경기
>
> | 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 1 초      | 128 MB      | 23994 | 12661 | 10562     | 52.634%   |
>
> ## 문제
>
> 상근이는 농구의 세계에서 점차 영향력을 넓혀가고 있다. 처음에 그는 농구 경기를 좋아하는 사람이었다. 농구에 대한 열정은 그를 막을 수 없었고, 결국 상근이는 농구장을 청소하는 일을 시작했다. 상근이도 농구장을 청소하면서 감독이 되기 위해 가져야할 능력을 공부해나갔다. 서당개 3년이면 풍월을 읊듯이 상근이는 점점 감독으로 한 걸음 다가가고 있었다. 어느 날 그에게 지방의 한 프로농구팀을 감독할 기회가 생기게 되었다. 그는 엄청난 지도력을 보여주며 프로 리그에서 우승을 했고, 이제 국가대표팀의 감독이 되었다.
>
> 내일은 일본과 국가대표 친선 경기가 있는 날이다. 상근이는 내일 경기에 나설 선발 명단을 작성해야 한다.
>
> 국가대표팀의 감독이 된 이후에 상근이는 매우 게을러졌다. 그는 선수의 이름을 기억하지 못하고, 각 선수의 능력도 알지 못한다. 따라서, 누가 선발인지 기억하기 쉽게 하기 위해 성의 첫 글자가 같은 선수 5명을 선발하려고 한다. 만약, 성의 첫 글자가 같은 선수가 5명보다 적다면, 상근이는 내일 있을 친선 경기를 기권하려고 한다.
>
> 상근이는 내일 경기를 위해 뽑을 수 있는 성의 첫 글자를 모두 구해보려고 한다.
>
> ## 입력
>
> 첫째 줄에 선수의 수 N (1 ≤ N ≤ 150)이 주어진다. 다음 N개 줄에는 각 선수의 성이 주어진다. (성은 알파벳 소문자로만 이루어져 있고, 최대 30글자이다)
>
> ## 출력
>
> 상근이가 선수 다섯 명을 선발할 수 없는 경우에는 "PREDAJA" (따옴표 없이)를 출력한다. PREDAJA는 크로아티아어로 항복을 의미한다. 선발할 수 있는 경우에는 가능한 성의 첫 글자를 사전순으로 공백없이 모두 출력한다.
>
> ## 예제 입력 1 복사
>
> ```
> 18
> babic
> keksic
> boric
> bukic
> sarmic
> balic
> kruzic
> hrenovkic
> beslic
> boksic
> krafnic
> pecivic
> klavirkovic
> kukumaric
> sunkic
> kolacic
> kovacic
> prijestolonasljednikovi
> ```
>
> ## 예제 출력 1 복사
>
> ```
> bk
> ```
>
> ## 예제 입력 2 복사
>
> ```
> 6
> michael
> jordan
> lebron
> james
> kobe
> bryant
> ```
>
> ## 예제 출력 2 복사
>
> ```
> PREDAJA
> ```

이것도 쉽다

counting 배열 문자 알고리즘 이용

-> Map 또는 Array 이용

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
int cnt[26];
int N;
string str;
int main(){

    cin>>N;
    for(int i=0;i<N;i++){
        cin>>str;
        cnt[str[0]-'a']++;
    }
    bool find=false;
    for(int i=0;i<26;i++){
        if(cnt[i]>=5) {
            cout<<(char)('a'+i);
            find=true;
        }
    }
    if(!find) cout<<"PREDAJA";

    return 0;
}

```

모범답안 : 개선점

1. string에 덧셈으로 더 간단하게 구현 (cpp는 형변환 유연함)
2. ret.size로 배열이 빈것을 체크

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
int cnt[26];
int N;
string str,ret;
int main(){

    cin>>N;
    for(int i=0;i<N;i++){
        cin>>str;
        cnt[str[0]-'a']++;
    }
    for(int i=0;i<26;i++) if(cnt[i]>=5) ret+=i+'a';
    if(ret.size()) cout<<ret<<"\n";
    else cout << "PREDAJA" << "\n";
    return 0;
}
```

---

# [11655] ROT13

> | 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 1 초      | 256 MB      | 26501 | 15809 | 13211     | 60.440%   |
>
> ## 문제
>
> ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.
>
> 예를 들어, "Baekjoon Online Judge"를 ROT13으로 암호화하면 "Onrxwbba Bayvar Whqtr"가 된다. ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. 앞에서 암호화한 문자열 "Onrxwbba Bayvar Whqtr"에 다시 ROT13을 적용하면 "Baekjoon Online Judge"가 된다.
>
> ROT13은 알파벳 대문자와 소문자에만 적용할 수 있다. 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다. 예를 들어, "One is 1"을 ROT13으로 암호화하면 "Bar vf 1"이 된다.
>
> 문자열이 주어졌을 때, "ROT13"으로 암호화한 다음 출력하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 알파벳 대문자, 소문자, 공백, 숫자로만 이루어진 문자열 S가 주어진다. S의 길이는 100을 넘지 않는다.
>
> ## 출력
>
> 첫째 줄에 S를 ROT13으로 암호화한 내용을 출력한다.
>
> ## 예제 입력 1 복사
>
> ```
> Baekjoon Online Judge
> ```
>
> ## 예제 출력 1 복사
>
> ```
> Onrxwbba Bayvar Whqtr
> ```
>
> ## 예제 입력 2 복사
>
> ```
> One is 1
> ```
>
> ## 예제 출력 2 복사
>
> ```
> Bar vf 1
> ```

존나 쉬울 줄 알았으나, char 형으로 변수 선언하였는데 오버플로우가 발생했어서 에러 잡는데 시간이 좀 소비된 문제

**char 형은 127까지인거를 기억하자**

**A 65 a 97**

모범답안 보다 내 답안이 더 좋음

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
string str;
int main(){


    getline(cin,str);
    for(int i=0;i<str.length();i++){
        int tmp;
        //small letter
        if(str[i]>='a' && str[i]<='z'){
            tmp=str[i]+13;
            if(tmp>'z') tmp-=26;
            str[i]=tmp;
        }
        //big letter
        else if(str[i]>='A' && str[i]<='Z'){
            tmp=str[i]+13;
            if(tmp>'Z') tmp-=26;
            str[i]=tmp;
        }
    }
    cout<<str<<endl;
    return 0;
}

```

---
